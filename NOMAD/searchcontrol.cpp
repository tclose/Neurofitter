/******************************************************************************
* NOMAD -  Nonlinear Optimization for Mixed vAriables and Derivatives.        *
* Copyright (C) 2001-2004  Gilles Couture - Ecole Polytechnique,              *
*                          Charles Audet - Ecole Polytechnique,               *
*		           John Dennis - Rice University.                     *
*                                                                             *
* Author: Gilles Couture                                                      *
* École Polytechnique de Montréal - GERAD                                     *
* C.P. 6079, Succ. Centre-ville, Montréal (Québec) H3C 3A7 Canada             *
* Tel:  (514) 340-6053 x6928                                                  *
* Email: Gilles.Couture@gerad.ca                                              *
* Fax: (514) 340-5665                                                         *
*                                                                             *
* This program is free software; you can redistribute it and/or               *
* modify it under the terms of the GNU General Public License                 *
* as published by the Free Software Foundation. You can find the              *
* GNU General Public License at:                                              *
*             http://www.gnu.org/copyleft/gpl.html                            *
*                                                                             *
* This program is distributed in the hope that it will be useful,             *
* but WITHOUT ANY WARRANTY; without even the implied warranty of              *
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               *
* GNU General Public License for more details.                                *
*                                                                             *
* You should have received a copy of the GNU General Public License           *
* along with this program; if not, write to the Free Software                 *
* Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. *
*                                                                             *
* You can find information on the NOMAD software at:                          *
*             http://www.gerad.ca/NOMAD/                                      *
******************************************************************************/

// searchcontrol.cpp -- SearchControl class methods.

#include <cmath>
#include <iostream>
using namespace std;
#include "augmentedpoint.h"
#include "defines.h"
#include "latinhypercubesearcher.h"
#include "randomsearcher.h"
#include "searchcontrol.h"
#include "searcher.h"
#include "speculativesearcher.h"
#include "surrogatecontrol.h"

// Private methods.
// ----------------

// This method deletes the list of points from memory.
void SearchControl::cleanList()
{
  if (!list_of_points.empty())
    {
      // The AugmentedPoint objects of the last iteration are destroyed.
      for (a_point = list_of_points.begin(); a_point != list_of_points.end();
	   a_point++)
	delete * a_point;
      list_of_points.clear();
    }
}

/* This method deletes the Searcher objects. It's called by the destructor, and
   by the 'continueRun' method. */
void SearchControl::deleteSearcherObjects()
{
  // The old list is erased.
  cleanList();
  // The Searcher objects are deleted.
  if (initial_search != NULL)
    delete initial_search;
  if (iterative_search != NULL)
    delete iterative_search;
  if (speculative_search != NULL)
    delete speculative_search;
}

// This method initializes the object's variables.
void SearchControl::initialize()
{
  initial = true;
  speculative_ok = false;
  a_point = list_of_points.begin();
  initial_search = NULL;
  iterative_search = NULL;
  speculative_search = NULL;
}

/* This method puts the points generated by the search on a very fine mesh:
   1/10000 of the current mesh size. */
void SearchControl::mesher(const unsigned int max_dim,
			   const double * incumbent, const double delta)
{
  // 'pt' is a pointer to the current point.
  double * pt = NULL;
  // The 'temp' array will hold some calculation results.
  double * temp = new double[max_dim];
  unsigned int i = 0;
  for (a_point = list_of_points.begin();
       a_point != list_of_points.end(); a_point++)
    {
      pt = (*a_point)->getPoint();
      // The point is put on the mesh in this loop, coordinate by coordinate.
      for (i = 0; i < max_dim; i++)
	{
	  // We keep only the first four digits with the 'floor' function.
	  temp[i] = floor((10000 * (pt[i] - incumbent[i]) / delta) + 0.5);
	  /* The point is put on the finer mesh, and stored in the vector
	     'trial'. */
	  pt[i] = incumbent[i] + (delta / 10000) * temp[i];
	}
    }
  if (display_factor >= 10)
    {
      cout << "List of points after 'mesher(...)':\n";
      showList();
    }
  // The memory is freed.
  delete [] temp;
}

// Public methods.
// ---------------

// Default constructor.
SearchControl::SearchControl(Evaluator & e)
  : eval(& e)
{
  display_factor = 0;
  surr_control = NULL;
  // The object's variables are initialized.
  initialize();
}

// Destructor.
SearchControl::~SearchControl()
{
  // This private method will delete the Searcher objects.
  deleteSearcherObjects();
}

// This method controls the entire search routine.
unsigned int SearchControl::search(const unsigned int max_dim,
				   const double delta,
				   const double * poll_center, bool success,
				   ofstream & fout, ofstream & fgraph,
				   ofstream & history)
{
  // This variable will tell Evaluator what type of search was done.
  int search_type = -1;
  // If the user doesn't want to do a search we do nothing.
  if ((initial_search == NULL) && (iterative_search == NULL) &&
      (speculative_search == NULL))
    return (0);
  else
    {
      // The old list is erased.
      cleanList();
      // The 'complete' variable tells us if the search is complete or not.
      bool complete = false;
      // If no search has been done (we're doing the initial search).
      if (initial)
	{
	  // We have to check if the 'initial_search' object exists, because
	  // the user might have chosen not to do an initial search.
	  if (initial_search != NULL)
	    {
	      complete = initial_search->search(max_dim, delta, poll_center,
						list_of_points, * eval);
	      // The list of points was generated by an initial search.
	      search_type = INITIAL;
	    }
	  // If there's a speculative search, the starting point must be sent
	  // to it.
	  if (speculative_search != NULL)
	    speculative_search->update(max_dim, poll_center);
	  // The boolean is put to 'false' (there's only one initial search per
	  // run!
	  initial = false;
	}
      else   // We're possibly doing an iterative search.
	{
	  // The speculative search is a one point search performed after an
	  // iteration success. It's used only with MADS poll directions.
	  if (speculative_search != NULL)
	    {
	      if (success)
		{
		  complete = speculative_search->search(max_dim, delta,
							poll_center,
							list_of_points,
							* eval);
		  // The list of points was generated by a speculative search.
		  search_type += SPECULATIVE + 1;
		}
	      else
		speculative_search->update(max_dim, poll_center);
	    }
	  // We have to check if the 'iterative_search' object exists, because
	  // the user might have chosen not to do an iterative search. The MADS
	  // dynamic search can be combined with a standard iterative search.
	  if (iterative_search != NULL)
	    {
	      complete = iterative_search->search(max_dim, delta, poll_center,
						  list_of_points, * eval);
	      // The list of points was generated by an iterative search.
	      search_type += ITERATIVE + 1;
	    }
	}
      if (display_factor >= 9)
	showList();
      // The points generated by the search are put on the mesh.
      mesher(max_dim, poll_center, delta);
      // If we use a surrogate ...
      if ((surr_control != NULL) && (list_of_points.size() > 0))
	{
	  // First we calculate the surrogate function values.
	  eval->evaluateFlow(max_dim, list_of_points);
	  // Then the points in the list are ordered by surrogate value.
	  surr_control->sortThisList(list_of_points);
	}
      // We give the list to Evaluator.
      return eval->processThisList(max_dim, list_of_points, complete, fout,
				   fgraph, history, search_type);
    }
}

// The user wants to continue the current run.
void SearchControl::continueRun()
{
  /* We don't know what searches the user wants to do, all search objects are
     destroyed. */
  deleteSearcherObjects();
  // The variables are reinitialized.
  initialize();
}

// This method creates the initial and iterative searches.
void SearchControl::createSearchers(const unsigned int ini_type,
			const bool ini_complete, const unsigned int ini_pts,
			const unsigned int iter_type, const bool iter_complete,
			const unsigned int iter_pts, const bool speculative)
{
  speculative_ok = speculative;
  // First we build the 'initial_search' object.
  switch(ini_type)
    {
      case 0  : break;
      case 1  : initial_search = new RandomSearcher(ini_pts, ini_complete,
						    * eval);
                break;
      case 2  : initial_search = new LatinHypercubeSearcher(ini_pts,
							    ini_complete,
							    * eval);
                break;
      default : cout << "That's not a search type!\n";
    }
  // Then we build the 'iterative_search' object.
  switch(iter_type)
    {
      case 0  : break;
      case 1  : iterative_search = new RandomSearcher(iter_pts, iter_complete,
						      * eval);
                break;
      case 2  : iterative_search = new LatinHypercubeSearcher(iter_pts,
							      iter_complete,
							      * eval);
                break;
      default : cout << "That's not a search type!\n";
    }
}

// The user chose MADS poll directions: a SpeculativeSearcher might be created.
void SearchControl::createSpeculativeSearch()
{
  // The SpeculativeSearcher object is created only if the user requested it.
  if (speculative_ok)
    speculative_search = new SpeculativeSearcher(1, false);
}

// This method links with the Surrogate object.
void SearchControl::linkWithSurrogate(SurrogateControl & surr)
{
  // SearchControl is linked with the SurrogateManager object.
  surr_control = & surr;
  /* FunctionControl must also be linked to SurrogateManager
     (Evaluator has a pointer to FunctionControl). */
  eval->linkWithSurrogate(surr);
}

// The display factor is reset.
void SearchControl::setDisplay(const unsigned int display)
{
  display_factor = display;
  // The display factor must be changed in these objects.
  if (initial_search != NULL)
    initial_search->setDisplay(display_factor);
  if (iterative_search != NULL)
    iterative_search->setDisplay(display_factor);
  if (speculative_search != NULL)
    speculative_search->setDisplay(display_factor);
}

// This method outputs the object's variables in the file 'fout'.
void SearchControl::showInput(ofstream & fout)
{
  if (!fout.is_open())
    return;
  if ((initial_search == NULL) && (iterative_search == NULL) &&
      (speculative_search == NULL))
    fout << "\nNo search.\n----------\n";
  else
    {
      if (initial_search != NULL)
	{
	  fout << "\nInitial search type:\n--------------------\n";
	  initial_search->showInput(fout);
	}
      if (iterative_search != NULL)
	{
	  fout << "\nIterative search type:\n----------------------\n";
	  iterative_search->showInput(fout);
	}
      if (speculative_search != NULL)
	{
	  fout << "\nSpeculative search: Executed after a successful iteration.";
	  fout << "\n-------------\n";
	}
    }
}

// Outputs the list of points generated by the search.
void SearchControl::showList()
{
  cout << "List of points generated by search:\n";
  if (list_of_points.empty())
    cout << "List of points empty!\n";
  else
    {
      // We traverse the list of points in this loop.
      for (a_point = list_of_points.begin();
	   a_point != list_of_points.end(); a_point++)
	(*a_point)->show();
    }
  cout << "\n";
}
