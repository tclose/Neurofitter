/******************************************************************************
* NOMAD -  Nonlinear Optimization for Mixed vAriables and Derivatives.        *
* Copyright (C) 2001-2004  Gilles Couture - Ecole Polytechnique,              *
*                          Charles Audet - Ecole Polytechnique,               *
*		           John Dennis - Rice University.                     *
*                                                                             *
* Author: Gilles Couture                                                      *
* École Polytechnique de Montréal - GERAD                                     *
* C.P. 6079, Succ. Centre-ville, Montréal (Québec) H3C 3A7 Canada             *
* Tel:  (514) 340-6053 x6928                                                  *
* Email: Gilles.Couture@gerad.ca                                              *
* Fax: (514) 340-5665                                                         *
*                                                                             *
* This program is free software; you can redistribute it and/or               *
* modify it under the terms of the GNU General Public License                 *
* as published by the Free Software Foundation. You can find the              *
* GNU General Public License at:                                              *
*             http://www.gnu.org/copyleft/gpl.html                            *
*                                                                             *
* This program is distributed in the hope that it will be useful,             *
* but WITHOUT ANY WARRANTY; without even the implied warranty of              *
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               *
* GNU General Public License for more details.                                *
*                                                                             *
* You should have received a copy of the GNU General Public License           *
* along with this program; if not, write to the Free Software                 *
* Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. *
*                                                                             *
* You can find information on the NOMAD software at:                          *
*             http://www.gerad.ca/NOMAD/                                      *
******************************************************************************/

/* pollcontrol.cpp -- PollControl class methods. All methods of the class are
   called from the Solver object, which has direct access to PollControl. */

#include <cmath>
#include <iostream>
using namespace std;
#include "augmentedpoint.h"
#include "continuouspollster.h"
#include "defines.h"
#include "pollcontrol.h"
#include "pollster.h"

// Private methods.
// ----------------

// Are these two integer arrays the same? (all their elements are equal).
bool PollControl::equal(const unsigned int max_dimension, int * old,
			int * _new)
{
  unsigned int i;
  if (display_factor >= 5)
    {
      cout << "Old proximity array: ";
      for (i = 0; i < max_dimension; i++)
	cout << old[i] << " ";
      cout << "\n";
      cout << "New proximity array: ";
      for (i = 0; i < max_dimension; i++)
	cout << _new[i] << " ";
      cout << "\n";
    }
  for (i = 0; i < max_dimension; i++)
    if (old[i] != _new[i])
      return false;
  return true;
}

// This method deletes the list of points from memory.
void PollControl::cleanList()
{
  if (!list_of_points.empty())
    {
      // The AugmentedPoint objects of the last iteration are destroyed.
      for (a_point = list_of_points.begin(); a_point != list_of_points.end();
	   a_point++)
	delete * a_point;
      list_of_points.clear();
    }
}

// Copy of an integer array into another.
void PollControl::copy(const unsigned int max_dimension, int * a, int * b)
{
  for (unsigned int i = 0; i < max_dimension; i++)
    a[i] = b[i];
}

// Outputs the list of points generated by the poll.
void PollControl::showList()
{
  cout << "List of points generated by poll:\n";
  if (list_of_points.empty())
    cout << "List of points empty!\n";
  else
    {
      // We traverse the list of points in this loop.
      for (a_point = list_of_points.begin();
	   a_point != list_of_points.end(); a_point++)
	(*a_point)->show();
    }
  cout << "\n";
}

/* This method is called when there is a success in the poll , i.e. when the
   point returned by the poll has a better truth function value than the 
   incumbent. */
void PollControl::success(const unsigned int index,
			  const unsigned int max_dimension)
{
  if (display_factor >= 5)
    cout << "\nChecking to reorder poll directions...\n";
  /* We check if the direction set has to be updated (the new incumbent is
     close to a bound). */
  bool direction_set_updated = updateDirectionSet(max_dimension);
  /* The poll directions are not reordered in these four cases:
     1- The successful poll direction was the first one.
     2- The user chose to poll according to a fixed order of directions.
     3- The user chose a complete poll (all directions will be evaluated
        anyway, why bother reordering them?).
     4- The direction set was updated (the incumbent is within epsilon of a
        constraint). */
  if ((index != 0) && (!fixed_order) &&
      (!pollster->getComplete()) && (direction_set_updated == false))
    // We tell 'direction_set' that there's a success.
    direction_set->success(index);
  else
    if (display_factor >= 5)
      cout << "No reordering.\n";
}

// Public methods.
// ---------------

/* Default constructor. PollControl is created at Start-up by the Solver
   object. */
PollControl::PollControl(Evaluator & e)
  : eval(& e)
{
  // The variables are set to default values.
  fixed_order = false;
  // The array is set to NULL;
  prox_array = NULL;
  display_factor = 0;
  // The list of points is empty.
  a_point = list_of_points.begin();
  // The direction set is set to NULL.
  direction_set = NULL;
  // The Pollster object is built, with default parameters.
  pollster = new ContinuousPollster(false);
  // The SurrogateControl object is set to NULL.
  surr_control = NULL;
}

// Destructor.
PollControl::~PollControl()
{
  if (prox_array != NULL)
    delete [] prox_array;
  // The old list is erased.
  cleanList();
  // The DirectionSet object is destroyed.
  if (direction_set != NULL)
    delete direction_set;
  // The Pollster object is destroyed.
  if (pollster != NULL)
    delete pollster;
}

/* This function is called when a new incumbent is found. It modifies the poll
   directions set when the incumbent is within epsilon of a boundary, if
   certain conditions are met (see below). */
bool PollControl::updateDirectionSet(const unsigned int max_dimension)
{
  bool value, use_constraints;
  int choice = direction_set->getChoice();
  use_constraints = eval->getConstraints();
  /* Nothing is done in these three cases:
     1- The user chose 2n poll directions.
     2- The user chose dense poll directions.
     3- There are no bound constraints. */
  if ((choice == 0) || (choice > 2) || (use_constraints == false))
    {
      if (display_factor >= 7)
	{
	  if (choice == 0)
	    cout << "2n directions! No need to rebuild.\n";
	  if (choice > 2)
	    cout << "Dense set of directions! No need to rebuild.\n";
	  if (use_constraints == false)
	    cout << "No constraints in the problem.\n";
	}
      value = false;
    }
  else   // We possibly need to update the set.
    {
      /* "temp" will contain the last proximity array from the bounds object.
	 It's initialized with '0' values. */
      int * temp = new int[max_dimension];
      for (unsigned int i = 0; i < max_dimension; i++)
	temp[i] = 0;
      /* ... we get the new proximity array (because the poll center
	 has changed, maybe the proximity array has too.) */
      copy(max_dimension, temp, eval->getProximityArray());
      // If the arrays are different, we need to change the polldirs set.
      if (!equal(max_dimension, prox_array, temp))
	{
	  // The proximity array has changed.
	  copy(max_dimension, prox_array, temp);
	  // The poll directions set is rebuilt.
	  direction_set->rebuildPollDirSet(prox_array, max_dimension);
	  value = true;
	}
      else   // The proximity array is the same.
	value = false;
      // The "temp" array is destroyed.
      delete [] temp;
    }
  return value;
}

// This method returns the user's poll directions choice.
int PollControl::getChoice()
{
  return direction_set->getChoice();
}

// This method does the poll phase (called every time the search fails).
unsigned int PollControl::poll(const unsigned int max_dim, const double delta,
			       const double factor, const double * poll_center,
			       ofstream & fout, ofstream & fgraph,
			       ofstream & history)
{
  // The old list is erased.
  cleanList();
  if (display_factor >= 5)
    {
      cout << "\nStart of local poll, delta = " << delta;
      cout << ", poll center: (";
      for (unsigned int z = 0; z < max_dim - 1; z++)
	cout << poll_center[z] << "  ";
      cout << poll_center[max_dim - 1] << ")\n";
      cout << "Current best iterate: ";
      eval->showIncumbent();
      cout << "\n";
    }

  // If the user chose a dense set of directions, we have to build them now.
  if (direction_set->getChoice() > 2)
    direction_set->makeDenseSet(max_dim, delta, factor);
  /* We call the poll method of Pollster; it returns a boolean, indicating
     if the poll is complete or not. */
  bool complete = pollster->poll(max_dim, delta, poll_center,
				 direction_set->getPollDirs(), list_of_points);
  // If we use a surrogate, we have to do these things:
  if (surr_control != NULL)
    {
      // First we calculate the surrogate function values.
      eval->evaluateFlow(max_dim, list_of_points);
      // Then the points are sorted in increasing order of surrogate values.
      surr_control->sortThisList(list_of_points);
    }
  if (display_factor >= 9)
    showList();
  /* The list of points is sent to Evaluator, to be evaluated by the objective
     function. The 'processThisList(...)' method returns an integer that
     indicates the degree of success of the poll. */
  unsigned int poll_success = eval->processThisList
    (max_dim, list_of_points, complete, fout, fgraph, history);
  /* There are 3 degrees of success:
     - poll_success = 0: Failure! The poll center stays the same, no points 
                         were added to the filter.
     - poll_success = 1: Partial success! The poll center stays the same, at
                         least one point was added to the filter.
     - poll_success = 2: Success! A new least infeasible incumbent was found.
     - poll_success = 3: Success! A new best feasible incumbent was found. */
  if (poll_success >= 2)
    success(eval->getPolldirIndex(), max_dim);
  return poll_success;
}

//
void PollControl::linkWithSurrogate(SurrogateControl & surr)
{
  surr_control = & surr;
}

// The user's choices for poll strategy and directions are recorded.
void PollControl::set(const unsigned int dimension, bool fixed,
		      bool complete, const unsigned int ch)
{
  fixed_order = fixed;

  // The old proximity array is destroyed.
  if (prox_array != NULL)
    {
      delete [] prox_array;
      prox_array = NULL;
    }
  /* A proximity array is built only when there are n + 1 ('ch' is equal to 1)
     or uniform directions ('ch' is equal to 2). */
  if ((ch == 1) || (ch == 2))
    {
      prox_array = new int[dimension];
      // 'prox_array' is initialized.
      for (unsigned int i = 0; i < dimension; i++)
	prox_array[i] = 0;
    }

  // The list of points is destroyed.
  cleanList();

  // The old DirectionSet object is destroyed.
  if (direction_set != NULL)
    delete direction_set;
  // The new DirectionSet is built.
  direction_set = new DirectionSet(ch, dimension);

  // Pollster's variables are set.
  pollster->set(complete);
}

// The display factor is reset.
void PollControl::setDisplay(const unsigned int display)
{
  display_factor = display;
  // The display factor must be changed in these objects.
  direction_set->setDisplay(display_factor);
  pollster->setDisplay(display_factor);
}

// show -- Outputs the poll strategy.
void PollControl::showInput(ofstream & fout)
{
  if (!fout.is_open())
    return;
  fout << "Poll strategy variables:\n";
  fout << "------------------------\n";
  fout << "Fixed order? ";
  fixed_order == true ?  fout << "Fixed\n" : fout << "Dynamic\n";
  pollster->showInput(fout);
  direction_set->showInput(fout);
}
