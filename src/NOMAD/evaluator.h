/******************************************************************************
* NOMAD -  Nonlinear Optimization for Mixed vAriables and Derivatives.        *
* Copyright (C) 2001-2004  Gilles Couture - Ecole Polytechnique,              *
*                          Charles Audet - Ecole Polytechnique,               *
*		           John Dennis - Rice University.                     *
*                                                                             *
* Author: Gilles Couture                                                      *
* École Polytechnique de Montréal - GERAD                                     *
* C.P. 6079, Succ. Centre-ville, Montréal (Québec) H3C 3A7 Canada             *
* Tel:  (514) 340-6053 x6928                                                  *
* Email: Gilles.Couture@gerad.ca                                              *
* Fax: (514) 340-5665                                                         *
*                                                                             *
* This program is free software; you can redistribute it and/or               *
* modify it under the terms of the GNU General Public License                 *
* as published by the Free Software Foundation. You can find the              *
* GNU General Public License at:                                              *
*             http://www.gnu.org/copyleft/gpl.html                            *
*                                                                             *
* This program is distributed in the hope that it will be useful,             *
* but WITHOUT ANY WARRANTY; without even the implied warranty of              *
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               *
* GNU General Public License for more details.                                *
*                                                                             *
* You should have received a copy of the GNU General Public License           *
* along with this program; if not, write to the Free Software                 *
* Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. *
*                                                                             *
* You can find information on the NOMAD software at:                          *
*             http://www.gerad.ca/NOMAD/                                      *
******************************************************************************/

/* evaluator.h -- class definition for Evaluator. This class controls the data
   flow between the FunctionControl, Constraints and AugmentedPoint objects. */

#ifndef _EVALUATOR_H_
#define _EVALUATOR_H_
#include "defines.h"
#include "generalconstraints.h"
#include "statistics.h"
#include "surrogatecontrol.h"
#include "terminator.h"

class AugmentedPoint;
class Constraints;
class Filter;
class FunctionControl;

class Evaluator
{
  /* Evaluator has the following variables:
     - 'display_factor' is used for debugging.
     - 'consecutive_fails' counts the number of consecutive failures, i.e.
       the number of consecutive function evaluations that did not find a
       better iterate.
     - 'polldir_index' indicates which point in the 'list_of_points' structure
       had a lower truth function value.
     - 'feasible_starting_point' indicates if the starting point is feasible or
       not.
     - We stop evaluating the lists of points generated by Search and Poll
       when 'terminate' is true.
     - Pointers to the best iterate.
     - Pointers to the Constraints, Filter and FunctionControl objects. */
 private:
  bool terminate;
  double surrogate_tolerance;
  unsigned int consecutive_fails, display_factor, polldir_index, teval;
  AugmentedPoint * incumbent, * starting_point;
  Constraints * constraints;
  Filter * filter;
  FunctionControl * f_control;
  Statistics stats;

  void initialize();
  void updateStatistics(const int sent_from, const unsigned int count,
			const double fx_decrease);
// Some class methods are described below, the others are in "evaluator.cpp".
 public:
  Evaluator(Terminator & t);
  ~Evaluator();
  // This method returns the incumbent (AugmentedPoint object).
  AugmentedPoint * getIncumbent() {return incumbent;}
  // This method returns the starting point (AugmentedPoint object).
  AugmentedPoint * getStartingPoint() {return starting_point;}
  bool feasible();
  bool getConstraints();
  double getTruth();
  double * getLowerBounds();
  double * getPollCenter(const bool feasible = true);
  double * getUpperBounds();
  // This method returns a pointer to the Filter object.
  Filter * getFilter() {return filter;}
  GeneralConstraints * getGenCons();
  int evaluateTruth(const unsigned int dim, AugmentedPoint * ap,
		    bool startingPoint = false);

  #ifdef PARANOMAD
	vector< int > parallelEvaluateTruth(const unsigned int dim, vector< AugmentedPoint * > points,
            bool startingPoint = false);
  #endif

  int * getProximityArray();
  unsigned int getNewTruthEvaluations();
  unsigned int getPermCacheHits();
  /* This method returns the index of the point in the 'list_of_points'
     structure (in 'process_this_list(...)' ) which was a new best iterate. */
  unsigned int getPolldirIndex() {return polldir_index;}
  unsigned int getTempCacheHits();
  /* This method returns the truth evaluations counter value of the last
     time that a new best iterate was found. */
  unsigned int getTeval() {return teval;}
  unsigned int getTruthEvaluations();
  unsigned int processThisList(const unsigned int dimension,
			       std::vector<AugmentedPoint *> & list_of_points,
			       bool complete_search, ofstream & fout,
			       ofstream & fgraph, ofstream & history,
			       const int sent_from = POLL);
  void buildEpsilonArray(const unsigned int dim, const double deltaT,
			 const double delta, const double factor);
  void closeCaches();
  void continueRun();
  void endProgram();
  void enterBlackBoxes(const char * dir, const char * input,
		       const char * truthF,
		       std::vector<const char *> & gen_constraints,
		       const char * surrF = NULL);
  void enterCache(const unsigned int dim, const unsigned int out_dim,
		  const char * perm);
  void enterFilter(const bool choice, const double h_max,
		   const double h_min, const unsigned int norm);
  void enterOutputTypes(const bool surr_used, const unsigned int gen_cons_nb);
  void enterProblem(const unsigned int dim, const unsigned int out_dim,
		    const unsigned int * out_index, double * coord,
		    const double * lower, const double * upper,
		    const unsigned int scaling, const double * scales,
		    const double low, const double up);
  void enterSurrogate(const double surr_tol);
  void evaluateFlow(const unsigned int dim,
		    std::vector<AugmentedPoint *> & list_of_points);
  void fillWithBestPoint(const unsigned int dim, double * coord);
  void isStartingPointFeasible();
  void linkWithSurrogate(SurrogateControl & surr);
  void setDisplay(const unsigned int display);
  void showIncumbent();
  void showIncumbent(ofstream & fout);
  void showInput(const unsigned int dim, ofstream & fout);
  void showOutput(ofstream & fout);
  void updateProximityArray(const unsigned int dimension);
  void writeHistoryLegend(ofstream & history);
};
#endif
